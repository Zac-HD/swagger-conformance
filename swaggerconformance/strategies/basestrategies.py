"""
Extra hypothesis strategies built from those in `hypothesis.strategies`, and
helper functions for merging dictionary type strategies and dictionaries of
strategies.
"""
import logging
import io

import hypothesis.strategies as hy_st

__all__ = ["json", "file_objects", "files",
           "merge_dicts_strategy", "merge_dicts_max_size_strategy",
           "merge_optional_dict_strategy"]


log = logging.getLogger(__name__)


def json(value_limit=5):
    """Hypothesis strategy for generating values that can be passed to
    `json.dumps` to produce valid JSON data.

    :param value_limit: A limit on the number of values in the JSON data -
                        setting this too high can cause value generation to
                        time out.
    :type value_limit: int
    """
    return hy_st.recursive(
        hy_st.none() | hy_st.booleans() | hy_st.floats() | hy_st.text(),
        lambda children: hy_st.dictionaries(hy_st.text(), children),
        max_leaves=value_limit)


def file_objects():
    """Hypothesis strategy for generating pre-populated `file objects`."""
    return hy_st.builds(io.BytesIO, hy_st.binary())


def files():
    """Hypothesis strategy for generating objects pyswagger can use as file
    handles to populate `file` format parameters.

    Generated values take the format: `dict('data': <file object>)`"""
    return file_objects().map(lambda x: {'data': x})


def merge_dicts_strategy(dict_strat_1, dict_strat_2):
    """Strategy merging two strategies producting dicts into one."""
    return hy_st.builds(lambda x, y: dict((list(x.items()) + list(y.items()))),
                        dict_strat_1,
                        dict_strat_2)


def merge_optional_dict_strategy(required_fields, optional_fields):
    """Combine dicts of strings mapping to required and optional strategies.

    :param required_fields: Mapping containing required fields.
    :type required_fields: dict(str)
    :param optional_fields: Mapping containing optional fields.
    :type optional_fields: dict(str)
    """
    # Create a strategy for a set of keys from the optional dict strategy, then
    # a strategy to build those back into a dictionary.
    # Finally, merge the strategy of selected optionals with the required one.
    opt_keys = hy_st.sets(hy_st.sampled_from(list(optional_fields.keys())))
    selected_optionals = hy_st.builds(
        lambda dictionary, keys: {key: dictionary[key] for key in keys},
        hy_st.fixed_dictionaries(optional_fields),
        opt_keys)
    result = merge_dicts_strategy(hy_st.fixed_dictionaries(required_fields),
                                  selected_optionals)
    return result


@hy_st.composite
def merge_dicts_max_size_strategy(draw, dict1, dict2, max_size):
    """Combine dict strategies into one to produce a dict up to a max size.

    Assumes both dicts have distinct keys and that dict1 is at most max_size.

    :param max_size: Maximum number of keys in dicts generated by the strategy.
    :type max_size: int
    """
    # This is fairly tricky to get right in a way that will not be flaky if
    # we try to reproduce an error, because dict iteration order is unreliable.
    result = draw(dict1)
    out2 = draw(dict2)
    assert len(result) <= max_size
    assert not set(result) & set(out2), 'Dicts must have distinct keys'
    subset = draw(hy_st.permutations(sorted(out2.items())))
    result.update(dict(subset[:max_size - len(result)]))
    return result
